(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{389:function(e,t,r){"use strict";r.r(t);var a=r(9),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"csrf攻击"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#csrf攻击"}},[e._v("#")]),e._v(" CSRF攻击")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("  攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。\n")])])]),r("h2",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),r("p",[e._v("CSRF攻击攻击原理及过程如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("   1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n\n   2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n\n   3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\n\n   4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n\n\n   5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 \n")])])]),r("h2",{attrs:{id:"防御手段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#防御手段"}},[e._v("#")]),e._v(" 防御手段")]),e._v(" "),r("h3",{attrs:{id:"验证-http-referer-字段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#验证-http-referer-字段"}},[e._v("#")]),e._v(" 验证 HTTP Referer 字段")]),e._v(" "),r("ul",[r("li",[e._v("Referer 的值是由浏览器提供的")])]),e._v(" "),r("p",[e._v("虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。")]),e._v(" "),r("ul",[r("li",[e._v("即便是使用最新的浏览器，黑客无法篡改 Referer 值")])]),e._v(" "),r("p",[e._v("这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。")]),e._v(" "),r("h3",{attrs:{id:"在请求地址中添加-token-并验证"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在请求地址中添加-token-并验证"}},[e._v("#")]),e._v(" 在请求地址中添加 token 并验证")]),e._v(" "),r("p",[e._v("CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中")]),e._v(" "),r("p",[e._v("因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。")]),e._v(" "),r("p",[e._v("要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。")]),e._v(" "),r("p",[e._v("csrf_token")]),e._v(" "),r("p",[e._v("对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 "),r("code",[e._v("http://url?csrftoken=tokenvalue。")]),e._v(" 而对于 POST 请求来说，要在 form 的最后加上 "),r("code",[e._v("<input type=”hidden” name=”csrftoken” value=”tokenvalue”/>")]),e._v("，这样就把 token 以参数的形式加入请求了。")]),e._v(" "),r("h3",{attrs:{id:"token加密"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#token加密"}},[e._v("#")]),e._v(" token加密")]),e._v(" "),r("p",[e._v("将"),r("code",[e._v("token")]),e._v("存在"),r("code",[e._v("cookie")]),e._v("中，URL中携带一个不同的"),r("code",[e._v("token")]),e._v(",依赖一个秘钥来解密或者做对比进行验证")])])}),[],!1,null,null,null);t.default=o.exports}}]);